<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/main/kotlin/Lexer.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/kotlin/Lexer.kt" />
              <option name="originalContent" value="package me.billbai.compiler.kwacc&#10;&#10;import java.io.InputStream&#10;&#10;class Lexer(private val inputStream: InputStream) {&#10;    private var curColumn: Int = 0&#10;    private var curLine: Int = 1&#10;    private var curCharCode: Int = 0&#10;    private var curChar: Char = 0.toChar()&#10;&#10;    private fun readChar() {&#10;        curCharCode = inputStream.read()&#10;        curChar = curCharCode.toChar()&#10;        if (curCharCode == -1) {&#10;            return&#10;        }&#10;        this.curColumn += 1&#10;        if (curCharCode == '\n'.code) {&#10;            this.curLine += 1&#10;            this.curColumn = 0&#10;        }&#10;    }&#10;&#10;    private fun makeIdentOrKeyword(identOrKeyword: String): Token {&#10;        return when (identOrKeyword) {&#10;            &quot;int&quot; -&gt; Token.Keyword(Token.KeywordType.INT)&#10;            &quot;void&quot; -&gt; Token.Keyword(Token.KeywordType.VOID)&#10;            &quot;return&quot; -&gt; Token.Keyword(Token.KeywordType.RETURN)&#10;            else -&gt; Token.Identifier(identOrKeyword)&#10;        }&#10;    }&#10;&#10;    private fun nextToken(): Token? {&#10;        try {&#10;            while (curCharCode != -1 &amp;&amp; curChar.isWhitespace()) {&#10;                readChar()&#10;            }&#10;&#10;            if (curCharCode == -1) {&#10;                return Token.EndOfFile&#10;            }&#10;&#10;            if (curChar.isLetter() || curChar == '_') {&#10;                val builder = StringBuilder()&#10;                do {&#10;                    builder.append(curChar)&#10;                    readChar()&#10;                } while(curCharCode != -1 &amp;&amp; (curChar.isLetterOrDigit() || curChar == '_'))&#10;                val identOrKeyword = builder.toString()&#10;                return makeIdentOrKeyword(identOrKeyword)&#10;            } else if (curChar.isDigit()) {&#10;                val builder = StringBuilder()&#10;                do {&#10;                    builder.append(curChar)&#10;                    readChar()&#10;                } while (curCharCode != -1 &amp;&amp; (curChar.isDigit()))&#10;                return Token.Constant(builder.toString())&#10;            } else {&#10;                val token = when (curChar) {&#10;                    '(' -&gt;  Token.OpenParen&#10;                    ')' -&gt;  Token.CloseParen&#10;                    '{' -&gt;  Token.OpenBrace&#10;                    '}' -&gt;  Token.CloseBrace&#10;                    ';' -&gt;  Token.Semicolon&#10;                    else -&gt; {&#10;                        println(&quot;Error: Invalid char $curChar ($curCharCode) for lexer&quot;)&#10;                        null&#10;                    }&#10;                }&#10;                readChar()&#10;                return token&#10;            }&#10;         } catch (e: Exception) {&#10;            println(&quot;Error reading input stream: ${e.message}&quot;)&#10;            return null&#10;        }&#10;    }&#10;&#10;    fun tokenize(): List&lt;Token&gt; {&#10;        readChar()&#10;        val tokens = mutableListOf&lt;Token&gt;()&#10;        do {&#10;            val token = nextToken()&#10;            if (token == null) {&#10;                println(&quot;Invalid token at position ${inputStream.available()}&quot;)&#10;                break&#10;            }&#10;            tokens.add(token)&#10;            if (token.tokenType == Token.TokenType.EOF) {&#10;                break&#10;            }&#10;        } while (true)&#10;        return tokens&#10;    }&#10;&#10;}" />
              <option name="updatedContent" value="package me.billbai.compiler.kwacc&#10;&#10;import java.io.InputStream&#10;&#10;class Lexer(private val inputStream: InputStream) {&#10;    &#10;    data class LexerError(&#10;        val message: String,&#10;        val line: Int,&#10;        val column: Int,&#10;        val character: Char? = null&#10;    )&#10;    &#10;    data class TokenizeResult(&#10;        val tokens: List&lt;Token&gt;,&#10;        val errors: List&lt;LexerError&gt;&#10;    ) {&#10;        val hasErrors: Boolean get() = errors.isNotEmpty()&#10;        val isSuccessful: Boolean get() = !hasErrors&#10;    }&#10;    &#10;    sealed class TokenResult {&#10;        data class Success(val token: Token) : TokenResult()&#10;        data class Error(val error: LexerError) : TokenResult()&#10;    }&#10;&#10;    private var curColumn: Int = 0&#10;    private var curLine: Int = 1&#10;    private var curCharCode: Int = 0&#10;    private var curChar: Char = 0.toChar()&#10;&#10;    private fun readChar() {&#10;        curCharCode = inputStream.read()&#10;        curChar = curCharCode.toChar()&#10;        if (curCharCode == -1) {&#10;            return&#10;        }&#10;        this.curColumn += 1&#10;        if (curCharCode == '\n'.code) {&#10;            this.curLine += 1&#10;            this.curColumn = 0&#10;        }&#10;    }&#10;&#10;    private fun makeIdentOrKeyword(identOrKeyword: String): Token {&#10;        return when (identOrKeyword) {&#10;            &quot;int&quot; -&gt; Token.Keyword(Token.KeywordType.INT)&#10;            &quot;void&quot; -&gt; Token.Keyword(Token.KeywordType.VOID)&#10;            &quot;return&quot; -&gt; Token.Keyword(Token.KeywordType.RETURN)&#10;            else -&gt; Token.Identifier(identOrKeyword)&#10;        }&#10;    }&#10;&#10;    private fun nextToken(): TokenResult {&#10;        try {&#10;            while (curCharCode != -1 &amp;&amp; curChar.isWhitespace()) {&#10;                readChar()&#10;            }&#10;&#10;            if (curCharCode == -1) {&#10;                return TokenResult.Success(Token.EndOfFile)&#10;            }&#10;&#10;            if (curChar.isLetter() || curChar == '_') {&#10;                val builder = StringBuilder()&#10;                do {&#10;                    builder.append(curChar)&#10;                    readChar()&#10;                } while(curCharCode != -1 &amp;&amp; (curChar.isLetterOrDigit() || curChar == '_'))&#10;                val identOrKeyword = builder.toString()&#10;                return TokenResult.Success(makeIdentOrKeyword(identOrKeyword))&#10;            } else if (curChar.isDigit()) {&#10;                val builder = StringBuilder()&#10;                do {&#10;                    builder.append(curChar)&#10;                    readChar()&#10;                } while (curCharCode != -1 &amp;&amp; curChar.isDigit())&#10;                &#10;                // Check for invalid number format (number followed by letter)&#10;                if (curCharCode != -1 &amp;&amp; curChar.isLetter()) {&#10;                    val invalidBuilder = StringBuilder(builder.toString())&#10;                    do {&#10;                        invalidBuilder.append(curChar)&#10;                        readChar()&#10;                    } while (curCharCode != -1 &amp;&amp; curChar.isLetterOrDigit())&#10;                    &#10;                    return TokenResult.Error(&#10;                        LexerError(&#10;                            &quot;Invalid number format: '${invalidBuilder}'&quot;,&#10;                            curLine,&#10;                            curColumn&#10;                        )&#10;                    )&#10;                }&#10;                &#10;                return TokenResult.Success(Token.Constant(builder.toString()))&#10;            } else {&#10;                val currentPos = curColumn&#10;                val currentLineNum = curLine&#10;                val invalidChar = curChar&#10;                &#10;                val token = when (curChar) {&#10;                    '(' -&gt;  Token.OpenParen&#10;                    ')' -&gt;  Token.CloseParen&#10;                    '{' -&gt;  Token.OpenBrace&#10;                    '}' -&gt;  Token.CloseBrace&#10;                    ';' -&gt;  Token.Semicolon&#10;                    else -&gt; {&#10;                        readChar() // Consume the invalid character&#10;                        return TokenResult.Error(&#10;                            LexerError(&#10;                                &quot;Unexpected character '$invalidChar'&quot;,&#10;                                currentLineNum,&#10;                                currentPos,&#10;                                invalidChar&#10;                            )&#10;                        )&#10;                    }&#10;                }&#10;                readChar()&#10;                return TokenResult.Success(token)&#10;            }&#10;         } catch (e: Exception) {&#10;            return TokenResult.Error(&#10;                LexerError(&#10;                    &quot;IO error while reading input: ${e.message}&quot;,&#10;                    curLine,&#10;                    curColumn&#10;                )&#10;            )&#10;        }&#10;    }&#10;&#10;    fun tokenize(): TokenizeResult {&#10;        readChar()&#10;        val tokens = mutableListOf&lt;Token&gt;()&#10;        val errors = mutableListOf&lt;LexerError&gt;()&#10;        &#10;        do {&#10;            when (val result = nextToken()) {&#10;                is TokenResult.Success -&gt; {&#10;                    tokens.add(result.token)&#10;                    if (result.token.tokenType == Token.TokenType.EOF) {&#10;                        break&#10;                    }&#10;                }&#10;                is TokenResult.Error -&gt; {&#10;                    errors.add(result.error)&#10;                    // Continue tokenizing after error to collect more potential errors&#10;                }&#10;            }&#10;        } while (curCharCode != -1)&#10;        &#10;        // Ensure we always have an EOF token&#10;        if (tokens.isEmpty() || tokens.last().tokenType != Token.TokenType.EOF) {&#10;            tokens.add(Token.EndOfFile)&#10;        }&#10;        &#10;        return TokenizeResult(tokens, errors)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>